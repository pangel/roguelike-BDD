<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"></meta>
    <!-- jQuery est une librairie qui simplifie la manipulation du DOM (= structure HTML)-->
    <!-- Un gros problème du Web c'est que les navigateurs font tous les choses un peu différemment.-->
    <!-- jQuery et d'autres librairies unifient les noms de fonctions et les comportements.-->
    <!-- jQuery ajoute l'objet global $ dans l'environnement. $ est aussi une fonction.-->
    <script src="http://code.jquery.com/jquery-1.9.1.min.js"></script>
    <!-- underscore est une librairie qui ajoute des méthodes de programmation fonctionnelle courante-->
    <!-- (each, map, fold, etc.)-->
    <!-- underscore ajoute l'objet global _. _ est aussi une fonction.-->
    <script src="http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.4.4/underscore-min.js"></script>

    <!-- Le CSS modifie l'apparence des éléments HTML.-->
    <!-- p { STYLE } == appliquer STYLE à tous les élément <p>...</p>-->
    <!-- .ha { STYLE } == appliquer STYLE à tous les éléments <[elem] class="ha">...</[elem]>-->
    <!-- #hi { STYLE } == appliquer STYLE à tous les éléments <[elem] id="hi">...</[elem]>-->
    <style rel="stylesheet">
      /* .w pour Wall,
         .o pour Open */
      .w, .o {
        /* Par défaut un élément a une position static
           et s'insère dans le flux du document (verticalement
           ou horizontalement).
           Une position absolute sort l'élément du flux (les autres
           éléments font comme s'il n'existait pas) et il doit être
           positionné en coordonnées absolues grâce aux propriétés
           top et left (qui sont modifiées plus tard). [1]
        */
        position: absolute;
        width: 50px;
        height: 85px;
        /* Les images des tiles font 100px par 170px
           background-size les remet à la bonne échelle
        */
        background-size: 100%;
      }

      .w {
        background-image: url('images/Wall%20Block.png');
        /* Comme les images ont une zone transparente en haut,
           background-position permet de les décaler
        */
        background-position: 0px -24px;
      }

      .o {
        background-image: url('images/Stone%20Block.png');
        background-position: 0px -24px;
      }

      .player {
        position: absolute;
        /* Arrondi des angles. Avec un arrondi assez grand
           on peut dessiner un cercle.
        */
        border-radius: 14px;
        width: 20px;
        height: 20px;
        /* Le a dans RGBa est pour alpha, la transparence entre 0 et 1 */
        background: rgba(0,0,230,0.6);
        top: 13px;
        left: 13px;
        /* Le z-index est la position en profondeur (coordonnée z) [2] */
        z-index: 1;
      }

      .debug .w, .debug .o {
        width: 39px;
        height: 39px;
        border: 1px solid rgba(255, 255, 0, 0.4);
      }

      /* [1] Les coordonnées sont relatives au noeud ancêtres positionné le plus proche.
         Un noeud est positionné quand il a position: relative, absolute ou fixed. */

      /* [2] Il y a plusieurs contextes de z-index; un pour les éléments avec
         position:static, un pour les éléments avec position:absolute, etc.
         C'est un peu plus compliqué parce qu'il est possible de créer des nouveaux
         contextes mais je ne suis pas expert. On risque de devoir bien connaître pour faire
         le jeu alors :
         http://www.w3.org/TR/CSS21/zindex.html
         https://developer.mozilla.org/en-US/docs/CSS/Understanding_z-index/The_stacking_context
         http://philipwalton.com/articles/what-no-one-told-you-about-z-index/
      */
    </style>
  </head>
  <body class="">
    <div class="player"></div>
    <script>

      // Ici on appelle la fonction $ et on lui passe en argument une fonction
      // anonyme. 

      // Ocaml: fun x -> x + 2
      // ==
      // Javascript: function(x) { return x + 2; }

      // La fonction $ éxécute son argument lorsque le document a été entièrement
      // chargé par le navigateur (alors que la fonction $ elle-même est exécutée
      // un peu plus tôt, quand le navigateur est prêt à exécuter le code de la page.
      // [3]
      $(function() {

        var tileShiftX = 50;
        var tileShiftY = 40;

        var carte = [
          ['w', 'w', 'w', 'w', 'w', 'w', 'w','w', 'w', 'w','w'],
          ['w', 'o', 'o', 'o','o', 'o', 'o','o', 'o', 'o', 'w'],
          ['w', 'o', 'o', 'o','o', 'o', 'o','o', 'o', 'o', 'w'],
          ['w', 'o', 'o', 'o','o', 'o', 'o','o', 'o', 'o', 'w'],
          ['w', 'o', 'o', 'o','o', 'o', 'o','o', 'o', 'o', 'w'],
          ['w', 'o', 'o', 'o','o', 'o', 'o','o', 'o', 'o', 'w'],
          ['w', 'o', 'o', 'o','o', 'o', 'o','o', 'o', 'o', 'w'],
          ['w', 'o', 'o', 'o','o', 'o', 'o','o', 'o', 'o', 'w'],
          ['w', 'o', 'o', 'o','o', 'o', 'o','o', 'o', 'o', 'w'],
          ['w', 'w', 'w', 'w', 'w', 'w', 'w','w', 'w', 'w','w']
        ];

        var keycodes = {
          37: 'left',
          38: 'up',
          39: 'right',
          40: 'down'
        };

        // App est l'objet global pour l'application.
        // En javascript ne pas mettre var devant une déclaration de variable
        // la rend globale. C'est inhabituel donc je préfère mettre toujours
        // var devant les variable est préciser window.myVar = ... quand je créé
        // une globale (window est le contexte global).
        window.App = {};

        // En javascript le constructeur d'un objet est juste une fonction.
        // Quand une fonction est appelée avec le mot clé new devant, un nouvel
        // objet vide est créé et chaque utilisation du mot clé this dans le corps
        // de la fonction fera référence à cet objet. La fonction renvoie ensuite 
        // automatiquement l'objet.
        var Creature = function() {
          this.x = 0;
          this.y = 0;
          this.$el = $('.player');
        };

        // Les objets héritent les uns des autres à travers leurs prototypes.
        // Ici tous les objets créés par new Creature() auront l'objet suivant
        // comme prototype, donc ils auront tous la méthode move.
        Creature.prototype = {

          move: function(x,y) {
            this.x = this.x + x;
            this.y = this.y + y;
            this.$el.css('left', ""+((this.x*tileShiftX)+13)+"px");
            this.$el.css('top', ""+((this.y*tileShiftY)+13)+"px");
          }

        };

        App.player = new Creature();

        // Equivalent de la configuration des touches dans un jeu.
        var keymap = {
          left:  function() { App.player.move(-1,0); },
          right: function() { App.player.move(1,0); },
          up:    function() { App.player.move(0,-1); },
          down:  function() { App.player.move(0,1); }
        };

        // A chaque touche relachée on regarde si on a une action configurée
        // pour cette touche. Comme ça on peut changer la configuration des touches
        // au cours du jeu.

        // $(document) : sélectionne la racine du document HTML.
        // $(E).on(EVENT, FN). Exécute FN quand l'élément E reçoit l'événement EVENT.
        // FN prend généralement EVENT en argument.
        $(document).on('keyup', function(event) {
          if (!event.shiftKey && !event.ctrlKey && keymap[keycodes[event.which]]) {

            // En javascript les événements sont déclenchés sur un noeud de l'arbre
            // du document puis remontent jusqu'à la racine. stopPropagation() bloque
            // leur remontée à partir du point courant.
            event.stopPropagation();

            // Là on appellerait par exemple keymap[keycodes[37]],
            // à savoir : function() { App.player.move(-1, 0); }
            // On lui passe l'objet event au cas où elle en aurait
            // besoin. Sinon pas de problème, l'arité des fonctions 
            // n'a aucune importance.
            keymap[keycodes[event.which]](event);
          }
        });


        _.each(carte, function(line, y, d) {
          _.each(line, function(tile, x, d) {
            // $(H) où H représente un morceau de HTML renvoie un morceau
            // d'arbre représentant ce HTML.
            var t = $('<div class="'+tile+'" ></div>');
            // On applique les proprietés top et left à la tile
            // (voir position:absolute plus haut).
            t.css({top: y*tileShiftY, left: x*tileShiftX});

            // append ajoute un élément en dernier fils d'un noeud.
            $('body').append(t);
          });
        });
      });

      // [3] Plus précisément $ exécute son argument quand tout le DOM (= structure HTML)
      // a été créé. Cela évite d'avoir du code qui demande l'élément X alors que X n'a
      // pas encore été créé.
    </script>
  </body>
</html>
